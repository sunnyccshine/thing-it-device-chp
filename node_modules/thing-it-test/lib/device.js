module.exports = {
    create: function () {
        return new Device();
    },
    bind: function (node, device) {
        utils.inheritMethods(device, new Device());

        utils.inheritMethods(device, require(
            node.plugins[device.plugin].modulePath).create());

        device.node = node;
        device.type = node.plugins[device.plugin];
        node[device.id] = device;
        device.logLevel = device.logLevel ? device.logLevel : node.logLevel;

        if (!device.actors) {
            device.actors = [];
        }

        if (!device.sensors) {
            device.sensors = [];
        }

        device.logDebug("Binding actors for device.");

        for (var n = 0; n < device.actors.length; ++n) {
            try {
                actor.bind(device, device.actors[n]);
            } catch (error) {
                device.logError("Failed to bind Actor [" + device.actors[n].id
                    + "]: " + error);
            }
        }

        device.logDebug("Binding sensors for device.");

        for (var n = 0; n < device.sensors.length; ++n) {
            try {
                sensor.bind(device, device.sensors[n]);
            } catch (error) {
                device.logError("Failed to bind Sensor [" + device.sensors[n].id
                    + "]: " + error);
            }
        }

        device.eventProcessors = [];

        device.logDebug("Device [" + device.id
            + "] bound.");


        return device;
    }
};

var q = require('q');
var utils = require("./utils");
var logger = require("./logger");
var sensor = require("./sensor");
var actor = require("./actor");

function Device() {
    this.class = "Device";

    utils.inheritMethods(this, logger.create());

    /**
     * Required for logging.
     */
    Device.prototype.publishMessage = function (content) {
        this.node.publishMessage(content);
    };

    /**
     *
     */
    Device.prototype.startDevice = function () {
        var deferred = q.defer();

        // For logging

        this.class = "Device";
        this.state = {};

        this.logInfo("Starting Device [" + this.label + "]");

        this.start().then(function () {
            this.completeStart().then(function () {
                deferred.resolve();
            }.bind(this)).fail(function (error) {
                this.logError(error);

                deferred.reject("Failed to start Device [" + this.label
                    + "] started: " + error);
            }.bind(this));
        }.bind(this)).fail(function (error) {
            this.logError(error);

            deferred.reject("Failed to start Device [" + this.label
                + "] started: " + error);
        }.bind(this));

        return deferred.promise;
    };

    /**
     *
     */
    Device.prototype.stopDevice = function () {
        var deferred = q.defer();

        this.logInfo("Stopping Device [" + this.label + "]");

        // TODO Make stop promise pattern

        for (var n = 0; n < this.actors.length; ++n) {
            this.actors[n].stopActor();
        }

        this.logDebug("Stopped Actors.");

        for (var n = 0; n < this.sensors.length; ++n) {
            this.sensors[n].stopSensor();
        }

        this.logDebug("Stopped Sensors.");
        this.logInfo("Device [" + this.label + "] stopped.");

        try {
            this.stop();
        } catch (error) {
            // TODO Publish error

            this.logError("Cannot stop device: " + error);
        }

        deferred.resolve();

        return deferred.promise;
    };

    /**
     *
     */
    Device.prototype.completeStart = function () {
        var deferred = q.defer();

        try {
            utils.promiseSequence(this.actors, 0, "startActor").then(function () {
                for (var n = 0; n < this.sensors.length; ++n) {
                    this.sensors[n].startSensor();
                }

                this.publishStateChange();

                this.logInfo("Device [" + this.label + "] started.");

                deferred.resolve();
            }.bind(this)).fail(function (error) {
                this.logError(error);

                deferred.reject(error);
            });
        }
        catch (error) {
            this.logError(error);

            deferred.reject(error);
        }


        return deferred.promise;
    };

    /**
     *
     */
    Device.prototype.findActorType = function (plugin) {
        for (var n = 0; n < this.type.actorTypes.length; ++n) {
            if (this.type.actorTypes[n].plugin === plugin) {
                return this.type.actorTypes[n];
            }
        }

        throw "Cannot find Actor Type [" + plugin + "].";
    };

    /**
     *
     */
    Device.prototype.findSensorType = function (plugin) {
        for (var n = 0; n < this.type.sensorTypes.length; ++n) {
            if (this.type.sensorTypes[n].plugin === plugin) {
                return this.type.sensorTypes[n];
            }
        }

        throw "Cannot find Sensor Type [" + plugin + "].";
    };

    /**
     *
     */
    Device.prototype.findActor = function (id) {
        for (var n = 0; n < this.actors.length; ++n) {
            if (this.actors[n].id == id) {
                return this.actors[n];
            }
        }

        throw "No actor exists with ID " + id + ".";
    };

    /**
     *
     */
    Device.prototype.isSimulated = function () {
        return (this.configuration && this.configuration.simulated) || this.node.isSimulated();
    };

    /**
     *
     */
    Device.prototype.publishEvent = function (event, data) {
        this.node.publishEvent({
            node: this.node.id,
            device: this.id,
            type: event,
            data: data
        });
    };

    /**
     *
     */
    Device.prototype.publishStateChange = function () {
        this.node.publishDeviceStateChange(this, this
            .getState());
    };
}